namespace <?php echo $this->namespace;?>;

use Zend\ModuleManager\ModuleManager;
use Zend\Mvc\MvcEvent;
use Zend\Validator\AbstractValidator;
use Zend\View\ViewEvent;
use Zend\View\Renderer\PhpRenderer;
use Zend\Http\Request as HttpRequest;
use Zend\View\Model\JsonModel;
use Zend\View\Model\ModelInterface;
use Zend\Log\Logger;
use Zend\Log\Writer\Stream;

/**
 * PHP Version 5
 *
 * @category Module
 * @package <?php echo $this->module.PHP_EOL;?>
 * @author Mauricio Piber <mauriciopiber@gmail.com>
 * @license GPL3-0 http://www.gnu.org/licenses/gpl-3.0.en.html
 * @link http://pibernetwork.com
 */
class Module
{
    const LOCATION = __DIR__;

    /**
     * Config executed on Bootstrap
     *
     * @param MvcEvent $mvcEvent Mvc Event
     *
     * @return void
     */
    public function onBootstrap(MvcEvent $mvcEvent)
    {
        // attach the JSON view strategy
        $app      = $mvcEvent->getTarget();
        $locator  = $app->getServiceManager();
        $view     = $locator->get('Zend\View\View');
        $strategy = $locator->get('ViewJsonStrategy');
        $view->getEventManager()->attach($strategy, 100);

        // attach a listener to check for errors
        $events = $mvcEvent->getTarget()->getEventManager();
        $events->attach(MvcEvent::EVENT_RENDER, array($this, 'onRenderError'));
    }

    public function shouldRender($event)
    {
        if (!$event->isError()) {
            return false;
        }

        // Check the accept headers for application/json
        $request = $event->getRequest();
        if (!$request instanceof HttpRequest) {
            return false;
        }

        $headers = $request->getHeaders();
        if (!$headers->has('Accept')) {
            return false;
        }

        // if we have a JsonModel in the result, then do nothing
        $currentModel = $event->getResult();
        if ($currentModel instanceof JsonModel) {
            return false;
        }

        return true;
    }

    public function onRenderError($event)
    {
        if (false === $this->shouldRender($event)) {
            return;
        }
        $currentModel = $event->getResult();
        $response = $event->getResponse();
        $model = new JsonModel([
            "httpStatus" => $response->getStatusCode(),
            "title" => $response->getReasonPhrase(),
        ***REMOVED***);

        // Find out what the error is
        $exception  = $currentModel->getVariable('exception');

        if ($currentModel instanceof ModelInterface && $currentModel->reason) {
            $model->detail = $this->exceptionHandler($currentModel);
        }

        if ($exception) {
            if ($exception->getCode()) {
                $event->getResponse()->setStatusCode($exception->getCode());
            }
            $model->detail = $exception->getMessage();

            // find the previous exceptions
            $messages = array();
            while ($exception = $exception->getPrevious()) {
                $messages[***REMOVED*** = "* " . $exception->getMessage();
            };
            if (count($messages)) {
                $exceptionString = implode("n", $messages);
                $model->messages = $exceptionString;
            }
        }

        // set our new view model
        $model->setTerminal(true);
        $event->setResult($model);
        $event->setViewModel($model);
    }

    public function exceptionHandler(ModelInterface $model)
    {
        switch ($model->reason) {
            case 'error-controller-cannot-dispatch':
                return 'The requested controller was unable to dispatch the request.';
            case 'error-controller-not-found':
                return 'The requested controller could not be mapped to an existing controller class.';
            case 'error-controller-invalid':
                return 'The requested controller was not dispatchable.';
            case 'error-router-no-match':
                return 'The requested URL could not be matched by routing.';
            default:
                return $model->message;
                break;
        }
    }

    /**
     * Return default autoloader config
     *
     * @return array
     */
    public function getAutoloaderConfig()
    {
        return [
            'Zend\Loader\StandardAutoloader' => [
                'namespaces' => [
                    __NAMESPACE__ => __DIR__ . '/../src/' . __NAMESPACE__,
                ***REMOVED***,
            ***REMOVED***,
        ***REMOVED***;
    }

    /**
     * Return module configurations
     *
     * @return array
     */
    public function getConfig()
    {
        return include __DIR__ . '/../config/module.config.php';
    }

    /**
     * Return Class Location on filesystem.
     *
     * @return string
     */
    public function getLocation()
    {
        return __DIR__;
    }
}
